# -*- coding: utf-8 -*-
"""Question2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hgBNm1sfbQXmRljdDB09oS-sUjzdyAI9
"""

from google.colab import drive
drive.mount('/content/drive/')

import os
import tables

header_1 = "/content/drive/My Drive/MCA - Assignment 1/"
header_2 = "/content/drive/My Drive/IIITD Stuff/MCA - Assignment 1/"

img_path = os.path.join(header_2, "images")
query_path = os.path.join(header_2, "train/query")
ground_truth_path = os.path.join(header_2, "train/ground_truth")
data_path = os.path.join(header_2, "Shwetank's Code/models/log_2")
query_output_path = os.path.join(header_2, "Shwetank's Code/queries/log_2")

import cv2
import numpy as np
import pickle
import matplotlib.pyplot as plt
from scipy import spatial
import math

imgs  = os.listdir(img_path)
imgs_base = [x.split('.')[0] for x in imgs]
print(str(len(imgs_base)) + " images received.")

count = 1
for node_name in imgs_base:
    print('processing file:' + str(count))
    count+=1
    img_file = node_name + ".jpg"
    im = cv2.imread(os.path.join(img_path, img_file), 0)
    h, w = im.shape
    ratio = min(100 / h, 100 / w)
    h = int(h * ratio)
    w = int(w * ratio)
    im = cv2.resize(im, (w, h))
    im = np.array(im)
    im = im / 255.0

    log_ims= []
    for i in range(9):
        sigma = 1.414 ** i
        log_im = np.square(cv2.Laplacian(cv2.GaussianBlur(im, (0, 0), sigma), cv2.CV_64F))
        log_ims.append(log_im)
    log_image_ims_np = np.array([i for i in log_ims])

    blob_centres = []
    max_sigma = 0
    for i in range(1, h-1):
        for j in range(1, w-1):
            sliced_img = log_image_ims_np[:, i-1:i+2, j-1:j+2]
            if np.amax(sliced_img) >= 0.005:
                z, x, y = np.unravel_index(sliced_img.argmax(), sliced_img.shape)
                max_sigma = max(max_sigma, 1.414 ** z)
                blob_centres.append(np.array([i + x - 1, j + y - 1, 1.414 ** z]))
    
    distance = 2 * 1.414 * max_sigma
    tree = spatial.cKDTree(np.array(blob_centres)[:, :-1])
    pairs = np.array(list(tree.query_pairs(distance)))
    if len(pairs) != 0:
        for (i, j) in pairs:
            blob1 = blob_centres[i]
            blob2 = blob_centres[j]
            r1 = blob1[-1] * 1.414
            r2 = blob2[-1] * 1.414
            d = np.sqrt(np.sum((blob1[:-1] - blob2[:-1])**2))
            if d > r1 + r2:
                area = 0
            elif d <= abs(r1 - r2):
                area = 1
            else:
                acos1 = math.acos(np.clip((d ** 2 + r1 ** 2 - r2 ** 2) / (2 * d * r1), -1, 1))
                acos2 = math.acos(np.clip((d ** 2 + r2 ** 2 - r1 ** 2) / (2 * d * r2), -1, 1))
                a = -d + r2 + r1
                b = d - r2 + r1
                c = d + r2 - r1
                d = d + r2 + r1
                area = (r1 ** 2 * acos1 + r2 ** 2 * acos2 -0.5 * np.sqrt(abs(a * b * c * d))) / (math.pi * (min(r1, r2) ** 2))
            if area > 0.5:
                if blob1[-1] > blob2[-1]:
                    blob2[-1] = 0
                else:
                    blob1[-1] = 0

    print(str(len(blob_centres)) + " blobs identified.")

    fig, ax = plt.subplots(2)
    ax[0].imshow(im, interpolation='nearest',cmap="gray")
    ax[1].imshow(im, interpolation='nearest',cmap="gray")
    for blob in blob_centres:
        y, x, r = blob
        c = plt.Circle((x, y), r*1.414, color='red', linewidth=1, fill=False)
        ax[0].add_patch(c)
    ax[0].plot()
    plt.show()
    break